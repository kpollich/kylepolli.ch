{
  "title": "Array Methods in JavaScript",
  "subtitle": "Common and useful methods on JavaScript's Array prototype",
  "date": "2019-12-23T05:00:00.000Z",
  "body": {
    "raw": "\nA few months ago, I gave a Lunch and Learn talk at work about some common methods and patterns for working with arrays in JavaScript. I had noticed some common confusion among some of the junior engineers on my team when working with collections of data, so I decided to collect some patterns and present them to team at large.\n\nThis post is a written adaptation of that talk. The original format for that talk was a walk through of the README and JavaScript files located in [this repo](https://github.com/kpollich/array-methods). There's also a quiz to test your array knowledge!\n\n# Intro - What are arrays?\n\nIf you're new to programming or JavaScript, you might not be completely sure what an array is. An array is the term that JavaScript uses for a list or collection of data. They look like this:\n\n```js\nconst fruits = [\"Strawberry\", \"Banana\", \"Apple\"];\n```\n\nDealing with arrays is very common in JavaScript development. Whether you're working with data from a REST API endpoint or the DOM, it's very likely that you'll often be working with collections of values or objects.\n\n# Native Array Methods\n\nJavaScript arrays have a bunch of native methods defined on the [Array prototype](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array). Because these methods are defined on the Array prototype, any Array will have access to these methods. This is the same for properties defined on the prototype, like `.length`.\n\n```js\nconst myFriends = [\"Jane\", \"John\", \"Joe\"];\n\n// Array.prototype.length\nconsole.log(myFriends.length); // 3\n```\n\nHaving a working knowledge of these native methods is great for improving your effectiveness and productivity with JavaScript. I'd definitely suggest reading over the [Array docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) from MDN, and taking a look at all the different array methods and examples there.\n\n# Why learn these methods?\n\n## Availability\n\nThese methods are always available to you. They're like a tool belt that comes for free whenever you're working in a JavaScript environment. JavaScript might not have a standard library ([yet](https://github.com/tc39/proposal-javascript-standard-library)), but it does provide lots of methods natively on its various prototypes like Array and Object.\n\n## Declarative\n\nJavaScript's native array methods are highly _[declarative](https://tylermcginnis.com/imperative-vs-declarative-programming/)_ as opposed to _imperative_. They tell the computer what to do, rather than how to do it. Because of this, complex chains of logic can be represented more succinctly or coherently with these methods as opposed to a big chain of nested `for` loops and `if` statements. That's not to say that `for` loops and `if` statements don't have their places, though!\n\n# forEach()\n\nThe first method we're going to take a look at is `.forEach()`. From the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)\n\n> The forEach() method executes a provided function once for each array element.\n\nSo, the `forEach()` method is called on any array, and accepts a [callback function](https://developer.mozilla.org/en-US/docs/Glossary/Callback_function) that will receive each element as its first argument. It looks like this, in practice:\n\n```js\nconst toys = [\"Truck\", \"Doll\", \"Ball\"];\n\ntoys.forEach((toy) => {\n  console.log(`You're getting a ${toy} for your birthday this year!`);\n});\n\n// Output:\n// You're getting a Truck for your birthday this year!\n// You're getting a Doll for your birthday this year!\n// You're getting a Ball for your birthday this year!\n```\n\nThe most common use case for `forEach()` is executing some code for each element of an array where the result of that execution either doesn't exist or doesn't matter. In our example above, we're outputting a string of text to the console, but we're not returning any data or calculating any new values based on the array's elements.\n\n`forEach()` is also useful for _mutating_ the original array. Mutations can sound a little scary, but sometimes they are necessary or even preferred. For instance, adding a new property to each object in an array of objects is a good use case for `forEach()`:\n\n```js\nconst users = [\n  { id: 1, name: \"Steph\"},\n  { id: 2, name: \"Steve}\n]\n\nusers.forEach(user => user.username = user.name + user.id)\n\nconsole.log(users)\n\n// Output:\n// [\n//   { id: 1, name: 'Steph', username: 'Steph1' },\n//   { id: 2, name: 'Steve', username: 'Steve2' }\n// ]\n```\n\nAs a learning exercise, let's re-implement each array method as we go. We'll keep things simple, and we won't handle edge cases or optional parameters like the real JavaScript methods do for simplicity's sake. Here's what our own `forEach()` might look like:\n\n```js\nfunction myForEach(array, callback) {\n  for (let i = 0; i < array.length; i++) {\n    callback(array[i]);\n  }\n}\n\nconst sides = [\"Fries\", \"Chips\", \"Salad\"];\nmyForEach(sides, (side) => console.log(side));\n\n// Output:\n// Fries\n// Chips\n// Salad\n```\n\nAt their core, a lot of these native array methods are syntactic sugar for common operation involving `for` loops like this. By creating named methods and accepting a callback, JavaScript can provide a robust, declarative interface for working with arrays, rather than leaving everything up to the user to implement imperatively.\n\n# map()\n\n`map()` is a method used for deriving a new array from another array. From [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\n\n> The map() method creates a new array with the results of calling a provided function on every element in the calling array.\n\n`map()` is most commonly used for transforming array data into a new structure, or running some sort of calculation on every element of an array. For instance, let's try doubling each number in an array with `map()`:\n\n```js\nconst numbers = [1, 2, 3, 4];\nconst doubledNumbers = numbers.map((number) => number * 2);\n\nconsole.log(doubledNumbers); // [2, 4, 6, 8]\nconsole.log(numbers); // [1, 2, 3, 4]\n```\n\nNotice how the original `numbers` array is untouched. This is because `map` returns a new array, rather than mutating the original. Mutations are a common source of bugs or unintended behavior in programming, so avoiding mutations unless explicitly necessary is typically a good practice.\n\nLet's write our own `map()` method like we did with `forEach()` above.\n\n```js\nfunction myMap(array, callback) {\n  const results = [];\n\n  for (let i = 0; i < array.length; i++) {\n    const result = callback(array[i]);\n    results.push(result);\n  }\n\n  return results;\n}\n\nconst numbers = [1, 2, 3, 4];\nconst squaredNumbers = myMap(numbers, (number) => number * number);\n\nconsole.log(squaredNumbers); // [1, 4, 9, 16]\n```\n\n# filter()\n\n`filter()` is a very well named method. It's used to filter down an array to a new array that contains only the elements that pass some condition. From [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter):\n\n> The filter() method creates a new array with all elements that pass the test implemented by the provided function.\n\nLet's stick with the list of numbers we used in our `map()` examples above, and try filtering down to only the even numbers.\n\n```js\nconst numbers = [1, 2, 3, 4];\n\nconst evens = numbers.filter((number = number % 2 === 0));\nconsole.log(evens); // [2, 4]\n```\n\nEvery time the callback function returns `true`, the element will be added to our resulting array. With that implementation in mind, let's create our own `filter()` as we did with the other array methods:\n\n```js\nfunction myFilter(array, callback) {\n  const results = [];\n\n  for (let i = 0; i < array.length; i++) {\n    const element = array[i];\n\n    if (callback(element)) {\n      results.push(element);\n    }\n  }\n\n  return results;\n}\n\nconst numbers = [1, 2, 3, 4];\nconst odds = myFilter(numbers, (number) => number % 2 !== 0);\n\nconsole.log(odds); // [1, 3]\n```\n\n# reduce()\n\n`reduce()` is perhaps the most complex of these standard array methods. Here's MDN's description:\n\n> The reduce() method executes a reducer function (that you provide) on each element of the array, resulting in a single output value.\n\nThe most common example of a use case for \"reduce\" is calculating the sum of all elements in an array. In this case, we're \"reducing\" many elements of an array into a single value: the sum. The signature for the \"reducer\" callback is a `function` that accepts an \"accumulator\" (the current value of the resulting single value) and the current element. It's common to see these arguments represented as `acc` and `curr` or similar. `reduce()` also accepts a second argument for the initial value of the accumulator. Let's take a look at our \"sum of array elements\" use case in code:\n\n```js\nconst numbers = [2, 4, 6, 8];\n\nconst sum = numbers.reduce((acc, curr) => {\n  return acc + curr;\n}, 0);\n\n// Or, with shorthand\nconst sum2 = numbers.reduce((sum, num) => sum + num, 0);\n\nconsole.log(sum); // 20\n```\n\n`reduce()` is useful for aggregating data about an array. For instance, determining the unique values for some string, and calculating how many times each value appears. Because of its relative complexity, workflows involving `reduce()` may often be represented more coherently with standard loops or a `forEach()`. Let's compare/contract an aggregation workflow with a plain loop and `reduce()` below:\n\n```js\n// Let's say we want to derive a new data structure from this array of users.\n// We want an object keyed by email, where each value is an array of\n// the user's post titles\nconst users = [\n  {\n    id: 1,\n    email: \"user@yahoo.com\",\n    posts: [{ title: \"Nope\", category: \"News\" }],\n  },\n  {\n    id: 2,\n    email: \"user@gmail.com\",\n    posts: [\n      { title: \"Good Post\", category: \"Fishing and Hunting\" },\n      { title: \"Another good one\", category: \"Topiaries\" },\n    ],\n  },\n  {\n    id: 3,\n    email: \"user2@gmail.com\",\n    posts: [\n      { title: \"Best Post Ever!\", category: \"Construction\" },\n      { title: \"A post\", category: \"Starbucks Secret Menu\" },\n    ],\n  },\n];\n\n// Plain loop implementation\nconst result1 = {};\nfor (const user of users) {\n  result[user.email] = user.posts;\n}\n\n// Reduce implementation\nconst result2 = users.reduce((acc, curr) => {\n  acc[user.email] = user.posts;\n\n  return acc;\n}, {});\n```\n\n`reduce()` is definitely the array method that's most conducive to overly clever code, but for succinct workflows it can still be an expressive method.\n\n# Others\n\nThere are a few other Array methods that are commonly used, and are a bit more straightforward than those we've looked at above. It's time for a ⚡lightning round ⚡!\n\n```js\n// `.some` - return true as long as at least one element satisfies the condition\n// returned by the callback\nconst hasEvenNumber = [1, 2, 3, 4].some((num) => num % 2 === 0);\nconsole.log(hasEvenNumber); // true\n\n// `.every` - return true as long as ALL elements satisfy the condition returned by the callback\nconst allEven = [2, 4, 6, 8].every((num) => num % 2 === 0);\nconsole.log(allEven); // true\n\n// `.find` - return the first value that satifsies the condition returned by the callback\nconst firstEven = [1, 2, 3, 4].find((num) => num % 2 === 0);\nconsole.log(firstEven); // 2\n\n// `.includes` - return true if the value is present in the array\nconst hasTwo = [1, 2, 3, 4].includes(2);\nconsole.log(hasTwo); // true\n```\n\n# Further Reading\n\nIf you're interested in flexing your Array knowledge, I provided a [quiz](https://github.com/kpollich/array-methods/blob/9d0666a44680ee892910e223cc930aa95b958e82/quiz.test.js) when I gave this blog post as a talk at work. You can clone the GitHub repo, and attempt to update that test file and make all the tests pass.\n\n- [MDN's documentation on Arrays](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)\n- [Sarah Drasner's Array Explorer](https://sdras.github.io/array-explorer/)\n- [Syntax.fm episode on Array + Object methods](https://syntax.fm/show/043/20-javascript-array-and-object-methods-to-make-you-a-better-developer)\n",
    "html": "<p>A few months ago, I gave a Lunch and Learn talk at work about some common methods and patterns for working with arrays in JavaScript. I had noticed some common confusion among some of the junior engineers on my team when working with collections of data, so I decided to collect some patterns and present them to team at large.</p>\n<p>This post is a written adaptation of that talk. The original format for that talk was a walk through of the README and JavaScript files located in <a href=\"https://github.com/kpollich/array-methods\">this repo</a>. There's also a quiz to test your array knowledge!</p>\n<h1>Intro - What are arrays?</h1>\n<p>If you're new to programming or JavaScript, you might not be completely sure what an array is. An array is the term that JavaScript uses for a list or collection of data. They look like this:</p>\n<pre><code class=\"language-js\">const fruits = [\"Strawberry\", \"Banana\", \"Apple\"];\n</code></pre>\n<p>Dealing with arrays is very common in JavaScript development. Whether you're working with data from a REST API endpoint or the DOM, it's very likely that you'll often be working with collections of values or objects.</p>\n<h1>Native Array Methods</h1>\n<p>JavaScript arrays have a bunch of native methods defined on the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\">Array prototype</a>. Because these methods are defined on the Array prototype, any Array will have access to these methods. This is the same for properties defined on the prototype, like <code>.length</code>.</p>\n<pre><code class=\"language-js\">const myFriends = [\"Jane\", \"John\", \"Joe\"];\n\n// Array.prototype.length\nconsole.log(myFriends.length); // 3\n</code></pre>\n<p>Having a working knowledge of these native methods is great for improving your effectiveness and productivity with JavaScript. I'd definitely suggest reading over the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\">Array docs</a> from MDN, and taking a look at all the different array methods and examples there.</p>\n<h1>Why learn these methods?</h1>\n<h2>Availability</h2>\n<p>These methods are always available to you. They're like a tool belt that comes for free whenever you're working in a JavaScript environment. JavaScript might not have a standard library (<a href=\"https://github.com/tc39/proposal-javascript-standard-library\">yet</a>), but it does provide lots of methods natively on its various prototypes like Array and Object.</p>\n<h2>Declarative</h2>\n<p>JavaScript's native array methods are highly <em><a href=\"https://tylermcginnis.com/imperative-vs-declarative-programming/\">declarative</a></em> as opposed to <em>imperative</em>. They tell the computer what to do, rather than how to do it. Because of this, complex chains of logic can be represented more succinctly or coherently with these methods as opposed to a big chain of nested <code>for</code> loops and <code>if</code> statements. That's not to say that <code>for</code> loops and <code>if</code> statements don't have their places, though!</p>\n<h1>forEach()</h1>\n<p>The first method we're going to take a look at is <code>.forEach()</code>. From the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\">MDN docs</a></p>\n<blockquote>\n<p>The forEach() method executes a provided function once for each array element.</p>\n</blockquote>\n<p>So, the <code>forEach()</code> method is called on any array, and accepts a <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Callback_function\">callback function</a> that will receive each element as its first argument. It looks like this, in practice:</p>\n<pre><code class=\"language-js\">const toys = [\"Truck\", \"Doll\", \"Ball\"];\n\ntoys.forEach((toy) => {\n  console.log(`You're getting a ${toy} for your birthday this year!`);\n});\n\n// Output:\n// You're getting a Truck for your birthday this year!\n// You're getting a Doll for your birthday this year!\n// You're getting a Ball for your birthday this year!\n</code></pre>\n<p>The most common use case for <code>forEach()</code> is executing some code for each element of an array where the result of that execution either doesn't exist or doesn't matter. In our example above, we're outputting a string of text to the console, but we're not returning any data or calculating any new values based on the array's elements.</p>\n<p><code>forEach()</code> is also useful for <em>mutating</em> the original array. Mutations can sound a little scary, but sometimes they are necessary or even preferred. For instance, adding a new property to each object in an array of objects is a good use case for <code>forEach()</code>:</p>\n<pre><code class=\"language-js\">const users = [\n  { id: 1, name: \"Steph\"},\n  { id: 2, name: \"Steve}\n]\n\nusers.forEach(user => user.username = user.name + user.id)\n\nconsole.log(users)\n\n// Output:\n// [\n//   { id: 1, name: 'Steph', username: 'Steph1' },\n//   { id: 2, name: 'Steve', username: 'Steve2' }\n// ]\n</code></pre>\n<p>As a learning exercise, let's re-implement each array method as we go. We'll keep things simple, and we won't handle edge cases or optional parameters like the real JavaScript methods do for simplicity's sake. Here's what our own <code>forEach()</code> might look like:</p>\n<pre><code class=\"language-js\">function myForEach(array, callback) {\n  for (let i = 0; i &#x3C; array.length; i++) {\n    callback(array[i]);\n  }\n}\n\nconst sides = [\"Fries\", \"Chips\", \"Salad\"];\nmyForEach(sides, (side) => console.log(side));\n\n// Output:\n// Fries\n// Chips\n// Salad\n</code></pre>\n<p>At their core, a lot of these native array methods are syntactic sugar for common operation involving <code>for</code> loops like this. By creating named methods and accepting a callback, JavaScript can provide a robust, declarative interface for working with arrays, rather than leaving everything up to the user to implement imperatively.</p>\n<h1>map()</h1>\n<p><code>map()</code> is a method used for deriving a new array from another array. From <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\">MDN</a></p>\n<blockquote>\n<p>The map() method creates a new array with the results of calling a provided function on every element in the calling array.</p>\n</blockquote>\n<p><code>map()</code> is most commonly used for transforming array data into a new structure, or running some sort of calculation on every element of an array. For instance, let's try doubling each number in an array with <code>map()</code>:</p>\n<pre><code class=\"language-js\">const numbers = [1, 2, 3, 4];\nconst doubledNumbers = numbers.map((number) => number * 2);\n\nconsole.log(doubledNumbers); // [2, 4, 6, 8]\nconsole.log(numbers); // [1, 2, 3, 4]\n</code></pre>\n<p>Notice how the original <code>numbers</code> array is untouched. This is because <code>map</code> returns a new array, rather than mutating the original. Mutations are a common source of bugs or unintended behavior in programming, so avoiding mutations unless explicitly necessary is typically a good practice.</p>\n<p>Let's write our own <code>map()</code> method like we did with <code>forEach()</code> above.</p>\n<pre><code class=\"language-js\">function myMap(array, callback) {\n  const results = [];\n\n  for (let i = 0; i &#x3C; array.length; i++) {\n    const result = callback(array[i]);\n    results.push(result);\n  }\n\n  return results;\n}\n\nconst numbers = [1, 2, 3, 4];\nconst squaredNumbers = myMap(numbers, (number) => number * number);\n\nconsole.log(squaredNumbers); // [1, 4, 9, 16]\n</code></pre>\n<h1>filter()</h1>\n<p><code>filter()</code> is a very well named method. It's used to filter down an array to a new array that contains only the elements that pass some condition. From <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\">MDN</a>:</p>\n<blockquote>\n<p>The filter() method creates a new array with all elements that pass the test implemented by the provided function.</p>\n</blockquote>\n<p>Let's stick with the list of numbers we used in our <code>map()</code> examples above, and try filtering down to only the even numbers.</p>\n<pre><code class=\"language-js\">const numbers = [1, 2, 3, 4];\n\nconst evens = numbers.filter((number = number % 2 === 0));\nconsole.log(evens); // [2, 4]\n</code></pre>\n<p>Every time the callback function returns <code>true</code>, the element will be added to our resulting array. With that implementation in mind, let's create our own <code>filter()</code> as we did with the other array methods:</p>\n<pre><code class=\"language-js\">function myFilter(array, callback) {\n  const results = [];\n\n  for (let i = 0; i &#x3C; array.length; i++) {\n    const element = array[i];\n\n    if (callback(element)) {\n      results.push(element);\n    }\n  }\n\n  return results;\n}\n\nconst numbers = [1, 2, 3, 4];\nconst odds = myFilter(numbers, (number) => number % 2 !== 0);\n\nconsole.log(odds); // [1, 3]\n</code></pre>\n<h1>reduce()</h1>\n<p><code>reduce()</code> is perhaps the most complex of these standard array methods. Here's MDN's description:</p>\n<blockquote>\n<p>The reduce() method executes a reducer function (that you provide) on each element of the array, resulting in a single output value.</p>\n</blockquote>\n<p>The most common example of a use case for \"reduce\" is calculating the sum of all elements in an array. In this case, we're \"reducing\" many elements of an array into a single value: the sum. The signature for the \"reducer\" callback is a <code>function</code> that accepts an \"accumulator\" (the current value of the resulting single value) and the current element. It's common to see these arguments represented as <code>acc</code> and <code>curr</code> or similar. <code>reduce()</code> also accepts a second argument for the initial value of the accumulator. Let's take a look at our \"sum of array elements\" use case in code:</p>\n<pre><code class=\"language-js\">const numbers = [2, 4, 6, 8];\n\nconst sum = numbers.reduce((acc, curr) => {\n  return acc + curr;\n}, 0);\n\n// Or, with shorthand\nconst sum2 = numbers.reduce((sum, num) => sum + num, 0);\n\nconsole.log(sum); // 20\n</code></pre>\n<p><code>reduce()</code> is useful for aggregating data about an array. For instance, determining the unique values for some string, and calculating how many times each value appears. Because of its relative complexity, workflows involving <code>reduce()</code> may often be represented more coherently with standard loops or a <code>forEach()</code>. Let's compare/contract an aggregation workflow with a plain loop and <code>reduce()</code> below:</p>\n<pre><code class=\"language-js\">// Let's say we want to derive a new data structure from this array of users.\n// We want an object keyed by email, where each value is an array of\n// the user's post titles\nconst users = [\n  {\n    id: 1,\n    email: \"user@yahoo.com\",\n    posts: [{ title: \"Nope\", category: \"News\" }],\n  },\n  {\n    id: 2,\n    email: \"user@gmail.com\",\n    posts: [\n      { title: \"Good Post\", category: \"Fishing and Hunting\" },\n      { title: \"Another good one\", category: \"Topiaries\" },\n    ],\n  },\n  {\n    id: 3,\n    email: \"user2@gmail.com\",\n    posts: [\n      { title: \"Best Post Ever!\", category: \"Construction\" },\n      { title: \"A post\", category: \"Starbucks Secret Menu\" },\n    ],\n  },\n];\n\n// Plain loop implementation\nconst result1 = {};\nfor (const user of users) {\n  result[user.email] = user.posts;\n}\n\n// Reduce implementation\nconst result2 = users.reduce((acc, curr) => {\n  acc[user.email] = user.posts;\n\n  return acc;\n}, {});\n</code></pre>\n<p><code>reduce()</code> is definitely the array method that's most conducive to overly clever code, but for succinct workflows it can still be an expressive method.</p>\n<h1>Others</h1>\n<p>There are a few other Array methods that are commonly used, and are a bit more straightforward than those we've looked at above. It's time for a ⚡lightning round ⚡!</p>\n<pre><code class=\"language-js\">// `.some` - return true as long as at least one element satisfies the condition\n// returned by the callback\nconst hasEvenNumber = [1, 2, 3, 4].some((num) => num % 2 === 0);\nconsole.log(hasEvenNumber); // true\n\n// `.every` - return true as long as ALL elements satisfy the condition returned by the callback\nconst allEven = [2, 4, 6, 8].every((num) => num % 2 === 0);\nconsole.log(allEven); // true\n\n// `.find` - return the first value that satifsies the condition returned by the callback\nconst firstEven = [1, 2, 3, 4].find((num) => num % 2 === 0);\nconsole.log(firstEven); // 2\n\n// `.includes` - return true if the value is present in the array\nconst hasTwo = [1, 2, 3, 4].includes(2);\nconsole.log(hasTwo); // true\n</code></pre>\n<h1>Further Reading</h1>\n<p>If you're interested in flexing your Array knowledge, I provided a <a href=\"https://github.com/kpollich/array-methods/blob/9d0666a44680ee892910e223cc930aa95b958e82/quiz.test.js\">quiz</a> when I gave this blog post as a talk at work. You can clone the GitHub repo, and attempt to update that test file and make all the tests pass.</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\">MDN's documentation on Arrays</a></li>\n<li><a href=\"https://sdras.github.io/array-explorer/\">Sarah Drasner's Array Explorer</a></li>\n<li><a href=\"https://syntax.fm/show/043/20-javascript-array-and-object-methods-to-make-you-a-better-developer\">Syntax.fm episode on Array + Object methods</a></li>\n</ul>"
  },
  "_id": "array-methods-in-javascript.md",
  "_raw": {
    "sourceFilePath": "array-methods-in-javascript.md",
    "sourceFileName": "array-methods-in-javascript.md",
    "sourceFileDir": ".",
    "contentType": "markdown",
    "flattenedPath": "array-methods-in-javascript"
  },
  "type": "Post",
  "url": "/blog/array-methods-in-javascript"
}