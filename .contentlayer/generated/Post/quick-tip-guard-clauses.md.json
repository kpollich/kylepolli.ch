{
  "title": "Quick Tip: Guard Clauses",
  "subtitle": "Reducing nesting and improving readability",
  "date": "2019-12-06T05:00:00.000Z",
  "body": {
    "raw": "\nThere are a few things that I find come up more often than others in code review. Whether I'm the one doing the review, or I'm receiving code review from a peer, there are some things that are just more obvious to someone with an outside perspective. One of these things, I've found, is the concept of [guard clauses](https://wiki.c2.com/?GuardClause) or early returns.\n\nLet's take a look at a block of JavaScript code as an example:\n\n```js\nfunction validateUser(user) {\n  if (user.email) {\n    const hasValidEmail = validateEmail(user.email);\n\n    if (user.password) {\n      const hasValidPassword = validatePassword(user.password);\n\n      return hasValidEmail && hasValidPassword;\n    }\n  }\n\n  return false;\n}\n```\n\nUsing `if` statements, we've set up some logic that translate to something like this:\n\n> If a user has an email, then validate the email. If a user has a password, then validate the password. If the email and password are valid, the user is valid. Otherwise, the user is invalid.\n\nIt's a bit hard to translate this sort of structure into pseudocode or plain English as we've written it, but what if we flipped the script a bit. What if we start with the conditions that denote an invalid user instead?\n\n> If a user doesn't have an email, they are invalid. If a user doesn't has a password, they are invalid. If a user has a valid email and password, they are valid.\n\nLet's see if we can translate this into code:\n\n```js\nfunction validateUser(user) {\n  if (!user.email || !user.password) {\n    return false;\n  }\n\n  const hasValidEmail = validateEmail(user.email);\n  const hasValidPassword = validatePassword(user.password);\n\n  return hasValidEmail && hasValidPassword;\n}\n```\n\nNow we've got a much more concise, more coherent method that's logically equivalent (proven by some [tests](https://codesandbox.io/s/guard-clause-tests-f0ehr)) to our previous one. This concept of \"inverting\" your conditions and pulling them up to the top of the method is called a \"Guard Clause\". Rather than nesting logic underneath positive/assertive conditions repeatedly, we can determine the negative conditions up front and bail out of a method right away.\n\nWhen you're deep in the implementation of some logic, it can be hard to see opportunities to invert conditions like this. During code review, though, a fresh pair of eyes is great for identifying areas where this particular refactor can be made.\n\nFurther Reading:\n\n- https://refactoring.com/catalog/replaceNestedConditionalWithGuardClauses.html\n- https://medium.com/@scadge/if-statements-design-guard-clauses-might-be-all-you-need-67219a1a981a\n",
    "html": "<p>There are a few things that I find come up more often than others in code review. Whether I'm the one doing the review, or I'm receiving code review from a peer, there are some things that are just more obvious to someone with an outside perspective. One of these things, I've found, is the concept of <a href=\"https://wiki.c2.com/?GuardClause\">guard clauses</a> or early returns.</p>\n<p>Let's take a look at a block of JavaScript code as an example:</p>\n<pre><code class=\"language-js\">function validateUser(user) {\n  if (user.email) {\n    const hasValidEmail = validateEmail(user.email);\n\n    if (user.password) {\n      const hasValidPassword = validatePassword(user.password);\n\n      return hasValidEmail &#x26;&#x26; hasValidPassword;\n    }\n  }\n\n  return false;\n}\n</code></pre>\n<p>Using <code>if</code> statements, we've set up some logic that translate to something like this:</p>\n<blockquote>\n<p>If a user has an email, then validate the email. If a user has a password, then validate the password. If the email and password are valid, the user is valid. Otherwise, the user is invalid.</p>\n</blockquote>\n<p>It's a bit hard to translate this sort of structure into pseudocode or plain English as we've written it, but what if we flipped the script a bit. What if we start with the conditions that denote an invalid user instead?</p>\n<blockquote>\n<p>If a user doesn't have an email, they are invalid. If a user doesn't has a password, they are invalid. If a user has a valid email and password, they are valid.</p>\n</blockquote>\n<p>Let's see if we can translate this into code:</p>\n<pre><code class=\"language-js\">function validateUser(user) {\n  if (!user.email || !user.password) {\n    return false;\n  }\n\n  const hasValidEmail = validateEmail(user.email);\n  const hasValidPassword = validatePassword(user.password);\n\n  return hasValidEmail &#x26;&#x26; hasValidPassword;\n}\n</code></pre>\n<p>Now we've got a much more concise, more coherent method that's logically equivalent (proven by some <a href=\"https://codesandbox.io/s/guard-clause-tests-f0ehr\">tests</a>) to our previous one. This concept of \"inverting\" your conditions and pulling them up to the top of the method is called a \"Guard Clause\". Rather than nesting logic underneath positive/assertive conditions repeatedly, we can determine the negative conditions up front and bail out of a method right away.</p>\n<p>When you're deep in the implementation of some logic, it can be hard to see opportunities to invert conditions like this. During code review, though, a fresh pair of eyes is great for identifying areas where this particular refactor can be made.</p>\n<p>Further Reading:</p>\n<ul>\n<li>https://refactoring.com/catalog/replaceNestedConditionalWithGuardClauses.html</li>\n<li>https://medium.com/@scadge/if-statements-design-guard-clauses-might-be-all-you-need-67219a1a981a</li>\n</ul>"
  },
  "_id": "quick-tip-guard-clauses.md",
  "_raw": {
    "sourceFilePath": "quick-tip-guard-clauses.md",
    "sourceFileName": "quick-tip-guard-clauses.md",
    "sourceFileDir": ".",
    "contentType": "markdown",
    "flattenedPath": "quick-tip-guard-clauses"
  },
  "type": "Post",
  "url": "/blog/quick-tip-guard-clauses"
}